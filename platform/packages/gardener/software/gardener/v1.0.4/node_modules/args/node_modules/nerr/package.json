{
  "name": "nerr",
  "version": "0.0.1",
  "description": "Properly constructed base class for error objects",
  "keywords": [
    "error",
    "exception"
  ],
  "author": {
    "name": "Dmitry Smolin",
    "email": "dimsmol@gmail.com"
  },
  "preferGlobal": false,
  "private": false,
  "dependencies": {
    "inh": "~0.0.1"
  },
  "engines": {
    "node": "~0.8.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/dimsmol/nerr"
  },
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/index",
  "readme": "# nerr\n\nUsing custom errors is tricky in JS. Unfortunately, it is not enough to just inherit your class from Error. You need to do really strange things to provide stack trace with your error objects.\n\n**nerr** fixes this problem by providing ErrorBase class. By inheriting it you are getting correct error implementation with stack trace included.\n\nErrorBase features:\n\n* Inherited from Error, all your error objects will be instances of Error\n* Fully Error-compatible, mimics all it's properties, code working with Error will also work with classes inherited from ErrorBase\n\t* but if `Object.defineProperties` is not available, you will need to use functions instead of `stack` and `message` properties, see below\n* `message` is getter, not just string property, you can override getMessage() to construct message you need using any of your error object properties\n\n## How to use\n\n* Inherit your error class from ErrorBase\n* Don't forget to call superclass constructor in your constructor\n* Override prototype.name by setting it to your class name\n* Override getMessage() to provide error message\n\nNote, that ErrorBase hasn't `message` argument that Error has. However, you can provide it in your error class yourself, as well as any other arguments and properties you may need. But be careful with property names. For example, inaccurate overriding of `message` property (which is a getter) can break functionality.\n\n## Usage example\n\nDefining custom error class:\n\n```js\nvar inherits = require('util').inherits;\nvar ErrorBase = require('nerr').ErrorBase;\n\nvar MyError = function (code) {\n\tErrorBase.call(this);\n\tthis.code = code;\n};\ninherits(MyError, ErrorBase);\n\nMyError.prototype.name = 'MyError';\n\nMyError.prototype.getMessage = function () {\n\treturn 'Error code: ' + this.code;\n};\n```\n\nUsing it:\n\n```js\ntry {\n\tthrow new MyError(500);\n}\ncatch(err) {\n\t// prints error name, message and stack trace\n\tconsole.log('Stack trace:\\n', err.stack);\n\n\tconsole.log();\n\n\t// prints error name and message\n\tconsole.log('Error:', err.toString());\n\n\tconsole.log();\n\n\tconsole.log('Error name:', err.name);\n\tconsole.log('Error message:', err.message);\n}\n```\n\n## How it works\n\nErrorBase constructor calls `Error.captureStackTrace(obj, func)` which provides an object instance with a `stack` getter (`func` is used to appropriately truncate captured stack trace, excluding error construction function).\n\n`stack` getter returns concatenation of obj.toString() and a captured stack trace. Obtained value is cached, so sequential getter calls will return the same value even if obj.toString() result is changed.\n\n## Compatibility\n\n`Error.captureStackTrace()` is undocumented feature of V8 (at least), so it's behavior can be changed.\n\nIf `captureStackTrace()` is not available, ErrorBase uses `new Error()` to get stack trace. In this case it cannot exclude error construction part of trace.\n\nIf `Object.defineProperties` is not available, `message` and `stack` getters will not be exposed, use `getMessage()` and `getStackTrace` functions instead.\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/dimsmol/nerr/issues"
  },
  "_id": "nerr@0.0.1",
  "_from": "nerr@~0.0.1"
}
